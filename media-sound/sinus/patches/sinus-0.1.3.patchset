From b33698c3c160afe05d82ed44927612ac6380d254 Mon Sep 17 00:00:00 2001
From: Bach Nguyen <bach5000@gmail.com>
Date: Wed, 21 Nov 2018 12:57:31 +0000
Subject: Fix little endian things


diff --git a/sinus.c b/sinus.c
index aaab435..f9c71f6 100644
--- a/sinus.c
+++ b/sinus.c
@@ -54,8 +54,8 @@ int options = 0;
 void print_useage( void )
 {
   fprintf(stdout, "useage: ");
-  fprintf(stdout, 
-      "%s [options] <freq1[/freq1R][:freq2[/freq2R]][,duration]> ...\n\n", 
+  fprintf(stdout,
+      "%s [options] <freq1[/freq1R][:freq2[/freq2R]][,duration]> ...\n\n",
       program_name);
   fprintf(stdout, " Options are:\n");
   fprintf(stdout, "  -b, --bits <n>\tset output to n bit audio\n");
@@ -199,7 +199,7 @@ void build_wave(struct wave_t *wave, double *freq1, double *freq2)
 
   bytes = wave->point_size;
 
-  // why is the /2 there? I don't know enough about frequency response 
+  // why is the /2 there? I don't know enough about frequency response
   // to say but it is neccessary
   // UPDATE: well after some searching I have found that it is because what
   //         I am really doing is taking the integral of the instantaneous
@@ -246,18 +246,22 @@ void wave_to_little_endian(struct wave_t *wave)
       p = wave->data;
       for(i=0; i<wave->data_size; i+=2)
       {
-        dprintf((stderr, "host -> le: %04X ->", (UINT16)*((UINT16 *)(p+i))));
-        (INT16)*((UINT16 *)(p+i)) = HOST_TO_LENDIAN_INT16(*((UINT16 *)(p+i)));
-        dprint((stderr, " %04X\n", (UINT16)*((UINT16 *)(p+i))));
+		UINT16* ptr = p;
+		ptr += i;
+        dprintf((stderr, "host -> le: %04X ->", *ptr));
+		*ptr = HOST_TO_LENDIAN_INT16(*ptr);
+        dprint((stderr, " %04X\n", *ptr));
       }
       return;
     case 4:
       p = wave->data;
       for(i=0; i<wave->data_size; i+=4)
       {
-        dprintf((stderr, "host -> le: %08X ->", (UINT32)*((UINT32 *)(p+i))));
-        (INT32)*((UINT32 *)(p+i)) = HOST_TO_LENDIAN_INT32(*((UINT32 *)(p+i)));
-        dprint((stderr, " %08X\n", (UINT32)*((UINT32 *)(p+i))));
+		UINT32* ptr = p;
+		ptr += i;
+        dprintf((stderr, "host -> le: %08X ->", *ptr));
+		*ptr = HOST_TO_LENDIAN_INT32(*ptr);
+        dprint((stderr, " %8X\n", *ptr));
       }
       return;
     default:
@@ -283,7 +287,7 @@ int write_wav(char *filename, struct wave_t *wave)
   wave_size = wave->data_size;
 
   if((fd=open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0666)) == -1)
-  { 
+  {
     fprintf(stderr, "error opening \"%s\" for writing: %s\n", filename, strerror(errno));
     goto ERR;
   }
@@ -295,7 +299,7 @@ int write_wav(char *filename, struct wave_t *wave)
     goto ERR;
   }
 
-  wf.chunkSize = HOST_TO_LENDIAN_INT32(sizeof(wf) - sizeof(wf.chunkID) - 
+  wf.chunkSize = HOST_TO_LENDIAN_INT32(sizeof(wf) - sizeof(wf.chunkID) -
       sizeof(wf.chunkSize));
   wf.FormatTag = HOST_TO_LENDIAN_INT16((INT16)1); // PCM formatted audio
   wf.Channels = HOST_TO_LENDIAN_INT16((UINT16)(wave->channels));
@@ -370,8 +374,8 @@ int parse_command(char *s, double *f1, double *f2, double *duration)
   char *t3 = NULL; // this MUST be initialized to NULL
   char *t4;
 
-  if(s == NULL) 
-  { 
+  if(s == NULL)
+  {
     return(-1);
   }
 
@@ -383,8 +387,8 @@ int parse_command(char *s, double *f1, double *f2, double *duration)
   {
     if((t3=strchr(t2, '/'))) { *t3++ = '\0'; }
   }
-  dprintf((stderr, "s: %s, t1: %s, t2: %s, t3: %s, t4: %s\n", 
-        s, t1 ? t1 : "(null)", t2 ? t2 : "(null)", 
+  dprintf((stderr, "s: %s, t1: %s, t2: %s, t3: %s, t4: %s\n",
+        s, t1 ? t1 : "(null)", t2 ? t2 : "(null)",
         t3 ? t3 : "(null)", t4 ? t4 : "(null)"));
 
   f1[0] = atof(s);
@@ -420,27 +424,27 @@ int main(int argc, char **argv)
 
   parse_args(argc, argv);
 
-  // check options and set defaults 
-  if(audio_dev == NULL) 
+  // check options and set defaults
+  if(audio_dev == NULL)
   {
     audio_dev = strdup(DEF_AUDIO_DEV);
   }
   switch(g_bits)
   {
-    case 8:  
+    case 8:
       signed_data = 0;
-      wave.pack = w.pack = pack_uint8; 
+      wave.pack = w.pack = pack_uint8;
       wave.unpack = w.unpack = unpack_uint8;
       break;
-    case 16: 
-      signed_data = 1; 
-      wave.pack = w.pack = pack_int16; 
-      wave.unpack = w.unpack = unpack_int16; 
+    case 16:
+      signed_data = 1;
+      wave.pack = w.pack = pack_int16;
+      wave.unpack = w.unpack = unpack_int16;
       break;
-    case 32: 
-      signed_data = 1; 
-      wave.pack = w.pack = pack_int32; 
-      wave.unpack = w.unpack = unpack_int32; 
+    case 32:
+      signed_data = 1;
+      wave.pack = w.pack = pack_int32;
+      wave.unpack = w.unpack = unpack_int32;
       break;
     default:
       fprintf(stderr, "only 8,16,32 bit audio is supported\n");
@@ -448,12 +452,12 @@ int main(int argc, char **argv)
       break;
   }
   if(g_channels < 1 || g_channels > 2)
-  { 
+  {
     fprintf(stderr, "only Stereo and Mono modes are supported\n");
     exit(1);
   }
   if(output_file == NULL && (options & OPT_NOPLAY))
-  { 
+  {
     fprintf(stderr, "nothing to do\n");
     exit(0);
   }
@@ -482,9 +486,9 @@ int main(int argc, char **argv)
     {
       if(freq1[j] > wave.rate/2 || freq2[j] > wave.rate/2)
       {
-        fprintf(stderr, 
+        fprintf(stderr,
             "warning: you have requested a frequency higher than 1/2 of your\n");
-        fprintf(stderr, 
+        fprintf(stderr,
             "         sampling rate(%d), Nyquest says no to this but I will\n",
             wave.rate/2);
         fprintf(stderr, "         let it slide.\n");
@@ -508,9 +512,9 @@ int main(int argc, char **argv)
       w.audio_min = 0;
     }
 
-    dprintf((stderr, "audio_max: %.0f, audio_min: %.0f\n", 
+    dprintf((stderr, "audio_max: %.0f, audio_min: %.0f\n",
           w.audio_max, w.audio_min));
-    dprintf((stderr, "%d samples using %d bytes of data\n", 
+    dprintf((stderr, "%d samples using %d bytes of data\n",
           w.samples, w.data_size));
 
     // update the sizes
@@ -533,28 +537,28 @@ int main(int argc, char **argv)
     // build our wave form
     if(w.channels == 2)
     {
-      printf("building %d sample (%.2f s, %.1f kB) wave %.1f/%.1f -> %.1f/%.1f\n", 
-          w.samples, duration, (float)w.data_size/1024, 
+      printf("building %d sample (%.2f s, %.1f kB) wave %.1f/%.1f -> %.1f/%.1f\n",
+          w.samples, duration, (float)w.data_size/1024,
           freq1[0], freq1[1], freq2[0], freq2[1]);
     }
     else
     {
-      printf("building %d sample (%.2f s, %.1f kB) wave %.1f -> %.1f\n", 
+      printf("building %d sample (%.2f s, %.1f kB) wave %.1f -> %.1f\n",
           w.samples, duration, (float)w.data_size/1024, freq1[0], freq2[0]);
     }
     build_wave(&w, freq1, freq2);
   }
 
-  printf("built a %d sample (%.2f s, %.1f kB) wave\n", 
+  printf("built a %d sample (%.2f s, %.1f kB) wave\n",
       wave.samples, total_duration, (float)wave.data_size/1024);
 
   // play the sample
   if(!(options & OPT_NOPLAY))
   {
-    printf("playing %.2f s %d Hz %d bit %s wave to \"%s\"\n", 
-        total_duration, wave.rate, wave.bits, 
+    printf("playing %.2f s %d Hz %d bit %s wave to \"%s\"\n",
+        total_duration, wave.rate, wave.bits,
         wave.channels == 2 ? "Stereo" : "Mono", audio_dev);
-    if((fd=open_audio(audio_dev, bufsiz, wave.bits, wave.rate, 
+    if((fd=open_audio(audio_dev, bufsiz, wave.bits, wave.rate,
             wave.channels)) == -1)
     {
       fprintf(stderr, "failed to open the audio device\n");
@@ -569,7 +573,7 @@ int main(int argc, char **argv)
   // write the wave to a .wav file
   if(output_file != NULL)
   {
-    printf("writing %.2f kB sample to \"%s\"\n", 
+    printf("writing %.2f kB sample to \"%s\"\n",
         (float)(sizeof(struct wavFormatChunk) + wave.data_size)/1024, output_file);
     write_wav(output_file, &wave);
   }
-- 
2.19.0

